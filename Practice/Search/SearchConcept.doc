查找的基本概念
给出一个值，在数据结构中找出关键字等于指定值的结点。查找结果有两种，查找成功和查找失败。

线性表的查找
1. 顺序查找
思路: 从表的一端开始，用给定的值与表中各结点的关键字逐个比较，直到找出相等的结点则查找成功，否则查找失败
优点: 简单
缺点: 查找时间长
平均查找长度:ASL=(N+1)/2
2. 二分查找
前提: 被查找的线性表是顺序存储且按关键字排序
思路: 讲被查找数R与中间位置的数mid=(low + high)/2进行比较，若R=R[mid],则查找成功。
      否则若R<R[mid],在前半段继续查找high=mid-1; 若R>R[mid],在后半段查找 low=mid+1.
      直到查到成功或者失败(low<high)时位置
平均查找长度: ASL=log2(n+1) -1

Hash查找法（散列表）
前提: 关键字与其存储位置有一定的函数关系
过程: 建立散列表；在散列表上进行查找
hash函数: 目标是使散列地址尽可能均匀的分布在散列空间上
    1.直接定址法； f(key)=a*key+b (简单，均匀不会产生冲突，适合表小并且连续)
    2.随机数法 f(key)=m*random(key) (使用于关键字长度不等的情况)
hash冲突: 对不同的关键字可能得到同一hash地址
解决冲突方法（开地址法和拉链法）
    -->开地址法（闭散列方法）: 当冲突发生时，顺序探查表的下一个单元，直到找到给定的关键字或碰到一个开放的空地址单元为止（放到这个空地方）
    -->拉链法(开散列方法)： 为散列表中的每个表目建立一个成为同义词字表的单链表
影响产生冲突多少有以下三个因素：
    1. 散列函数是否均匀；
    2. 处理冲突的方法；
    3. 散列表的装填因子。
    散列表的装填因子定义为：α = 填入表中的元素个数 / 散列表的长度
二次聚集现象

BST(binary sort tree)二叉排序树
定义： 是一颗空树或者1.左子树的所有节点的关键字都小于根结点，右子树的所有节点关键字都大于根结点；左右字数也是二叉排序树
ADT(抽象数据类型，只研究结构不考虑细节)
BST查找思路: 从根节点开始，用给定值K与当前结点的关键字进行比较。1. 若当前结点为空，则查找失败；2.若K等于当前结点
            则查找成功；3.若K小于当前结点，则进入左子树根节点继续比较；4.若K大于当前结点，则进入右子树根节点继续比价
BST插入：将待插结点与树根进行比较，若待插结点小根节点，则进入左子树，否则进入右子树，直到把新节点座位一个新的树叶插入到二叉排序树中
BST删除:在二叉排序树中删去一个结点，分三种情况讨论：
    1.若*p结点为叶子结点，即PL(左子树)和PR(右子树)均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。
    2.若p结点只有左子树PL或右子树PR，此时只要令PL或PR直接成为其双亲结点f的左子树（当p是左子树）或右子树（当p是右子树）即可，作此修改也不破坏二叉排序树的特性。
    3.若p结点的左子树和右子树均不空。在删去p之后，为保持其它元素之间的相对位置不变，可按中序遍历保持有序进行调整。比较好的做法是，找到p的直接前驱（或直接后继）s，用s来替换结点p，然后再删除结点s。
最好ASL= O(Log2n) (与二分查找一样)
最坏ASL =O(n) (一棵斜树，与顺序查找一样)

AVL平衡二叉树
定义：平衡因子只能取值1,0 或者 -1的二叉树
ADT及其实现: bf|key|lchild|rchild|  其中bf为其平衡因子
平衡调整
    1.Left Rotation 左旋，右子树上加入右子节点
    2.Right Rotation 右旋，左子树上加入左子节点
    3.Right-Left Rotaion 先右旋再左旋，右子树上加入左节点
    4.Left-Right Rotaion 先左旋再右旋，左子树上加入右节点
平衡树查找: 
平衡树插入：1. 按照BST的插入新结点； 2.修改平衡因子； 3.做平衡调整
平衡树删除: 2. 按照BST的删除结点； 2. 修改平衡因子； 3. 做平衡调整


堆
堆的定义: 完全二叉树中任何分支结点均不大于（均不小于）其左右子女结点。
堆的生成:自下而上用筛选法生成堆
堆的调整算法: 
范围查询： 
